import os
import re
import sys
import glob
import time
import shutil
import hashlib


configfile: "config/config.yaml"


include: "rules/patterns.smk"
include: "rules/common.smk"


DRY_RUN = any("-n" in arg for arg in sys.argv[1:])
INCOMPLETE_FILES = move_incomplete_files(
    config.get("incomplete_files"), is_dry_run=DRY_RUN
)
RUN_DIRS, SUBRUN_DIRS, FLOWCELL_DIRS = get_run_dir_wcs(rgx_dir_pattern=RGX_DIR_PATTERN)
DEVICES = config["dorado"].get("devices", "all")


wildcard_constraints:
    run_dir="|".join(RUN_DIRS),
    subrun_dir="|".join(SUBRUN_DIRS),
    flowcell="|".join(FLOWCELL_DIRS),


# Check status of run by doing dry-run. If non-zero and error msg contaings IncompleteOutputException, update config wiht rebasecall.
# Then change params and output to include previous file.
checkpoint dorado_basecaller:
    input:
        dorado_bin=config["dorado"]["bin"],
        pod5_directory=os.path.join(
            config["input_dir"], "{run_dir}", "{subrun_dir}", "{flowcell}", "pod5"
        ),
        rebasecall_file=lambda wc: (
            INCOMPLETE_FILES[expand_path(wc, READS_FILE)]
            if INCOMPLETE_FILES.get(expand_path(wc, READS_FILE)) and not DRY_RUN
            else []
        ),
    output:
        reads=os.path.join(
            OUTPUT_DIR,
            "{run_dir}.bam",
        ),
    resources:
        devices=DEVICES,
    params:
        rebasecall_file=lambda wc, input: get_rebasecall_params(
            wc, input, INCOMPLETE_FILES, dry_run=DRY_RUN
        ),
        kit_name_arg=lambda wc: get_kit_name_arg(wc.run_dir),
        recursive="--recursive",
        model=config["dorado"]["model"],
        modifications=lambda wc: get_modifications(wc.run_dir),
        min_qscore=config["dorado"]["min_qscore"],
    # Only allow up to one process at a time.
    threads: workflow.cores
    log:
        "logs/dorado_basecaller/{run_dir}_{subrun_dir}_{flowcell}.log",
    benchmark:
        "benchmarks/dorado_basecaller/{run_dir}_{subrun_dir}_{flowcell}.tsv"
    shell:
        """
        {input.dorado_bin} basecaller \
            {params.model},{params.modifications} \
            {params.recursive} \
            --min-qscore {params.min_qscore} \
            --device cuda:{resources.devices} \
            {params.rebasecall_file} {params.kit_name_arg} \
            {input.pod5_directory} > {output.reads} 2> {log}
        """

checkpoint dorado_demux:
    input:
        bam=rules.dorado_basecaller.output.reads,
    output:
        output_dir=directory(os.path.join(
            OUTPUT_DIR,
            "demux_{run_dir}",
        ))
    threads: workflow.cores
    log:
        "logs/dorado_demux/{run_dir}_{subrun_dir}_{flowcell}.log",
    benchmark:
        "benchmarks/dorado_demux/{run_dir}_{subrun_dir}_{flowcell}.tsv"
    shell:
        """
        dorado demux --output-dir {output.output_dir} --no-classify {input.bam} 2> {log}
        """


def bam_files(wc):
    output_bam = checkpoints.dorado_basecaller.get(**wc).output
    kit_name_arg = get_kit_name_arg(wc.run_dir)

    if not kit_name_arg:
        return output_bam
    else:
        demux_dir = checkpoints.dorado_demux.get(**wc).output[0]
        # Only emit demultiplexed files.
        return glob.glob(os.path.join(demux_dir, "*.bam"))


rule generate_summary:
    input:
        script="workflow/scripts/ont_stats.py",
        bam=bam_files,
        demux_chkpt=lambda wc: (
            rules.dorado_demux.output
            if get_kit_name_arg(wc.run_dir)
            else []
        )
    output:
        tsv=os.path.join(
            OUTPUT_DIR,
            "{run_dir}.tsv",
        ),
        plot=os.path.join(
            OUTPUT_DIR,
            "{run_dir}.pdf",
        ),
        # Output to both directory and checkpoint dir.
        # We need to do this because if marker file is transferred before all pod5s (which happens often), we don't want to rebasecall.
        marker_file=touch(os.path.join(OUTPUT_DIR, "basecalling.done")),
    params:
        chkpt_file=create_chkpt_fname,
    log:
        "logs/dorado_basecaller/{run_dir}_{subrun_dir}_{flowcell}_summary.log",
    threads: 24
    conda:
        "envs/tools.yaml"
    shell:
        """
        python {input.script} {input.bam} -s {wildcards.run_dir} -t {threads} -o {output.tsv} -p {output.plot} 2> {log}
        touch {params.chkpt_file}
        """


rule convert_to_fastq:
    input:
        bam=rules.dorado_basecaller.output.reads,
    output:
        fq=temp(os.path.join(OUTPUT_DIR, "{run_dir}.fq.gz")),
    params:
        preserve_all_tags="-T '*'",
    threads: workflow.cores
    log:
        "logs/convert_to_fastq/{run_dir}_{subrun_dir}_{flowcell}.log",
    conda:
        "envs/tools.yaml"
    shell:
        """
        {{ samtools fastq {params.preserve_all_tags} -@ {threads} {input.bam} | \
        bgzip -@ {threads};}} > {output} 2> {log}
        """


rule dorado_correct:
    input:
        dorado_bin=config["dorado"]["bin"],
        fq=rules.convert_to_fastq.output,
    output:
        corrected_fa=os.path.join(OUTPUT_DIR, "{run_dir}.fa.gz"),
        marker_file=touch(os.path.join(OUTPUT_DIR, "correction.done")),
    resources:
        devices=DEVICES,
    threads: workflow.cores
    log:
        "logs/dorado_correct/{run_dir}_{subrun_dir}_{flowcell}.log",
    conda:
        "envs/tools.yaml"
    shell:
        """
        {{ {input.dorado_bin} correct \
        --threads {threads} \
        --devices cuda:{resources.devices} {input.fq} | \
        bgzip -@ {threads} ;}} > {output.corrected_fa} 2> {log}
        """


rule all:
    input:
        expand(
            rules.dorado_basecaller.output,
            zip,
            run_dir=RUN_DIRS,
            subrun_dir=SUBRUN_DIRS,
            flowcell=FLOWCELL_DIRS,
        ),
        expand(
            rules.generate_summary.output,
            zip,
            run_dir=RUN_DIRS,
            subrun_dir=SUBRUN_DIRS,
            flowcell=FLOWCELL_DIRS,
        ),
        (
            expand(
                rules.dorado_correct.output,
                zip,
                run_dir=RUN_DIRS,
                subrun_dir=SUBRUN_DIRS,
                flowcell=FLOWCELL_DIRS,
            )
            if config["dorado"]["correct"]
            else []
        ),
    default_target: True
